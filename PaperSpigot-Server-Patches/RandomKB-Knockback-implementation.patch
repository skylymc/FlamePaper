From 06dd9289049c7175e7e612b51ee898bc46b5ae64 Mon Sep 17 00:00:00 2001
From: anonymous <anonymous@gmail.com>
Date: Sun, 9 Oct 2022 00:06:09 +0200
Subject: [PATCH] RandomKB - Knockback Implementation


diff --git a/pom.xml b/pom.xml
index a6641f15..64dbc397 100644
--- a/pom.xml
+++ b/pom.xml
@@ -93,6 +93,11 @@
             <artifactId>hamcrest-library</artifactId>
             <version>1.3</version>
             <scope>test</scope>
+        </dependency>
+		<dependency>
+            <groupId>net.jafama</groupId>
+            <artifactId>jafama</artifactId>
+            <version>2.3.2</version>
         </dependency>
     </dependencies>
 
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index e345dd7b..f91e7a86 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -17,6 +17,9 @@ import org.bukkit.entity.LivingEntity;
 import org.bukkit.entity.Painting;
 import org.bukkit.entity.Vehicle;
 import org.spigotmc.CustomTimingsHandler; // Spigot
+
+import eu.shifo.pvp.RandomKB;
+
 import org.bukkit.event.entity.EntityCombustByEntityEvent;
 import org.bukkit.event.hanging.HangingBreakByEntityEvent;
 import org.bukkit.event.painting.PaintingBreakByEntityEvent;
@@ -2216,4 +2219,29 @@ public abstract class Entity implements ICommandListener {
 
         EnchantmentManager.b(entityliving, entity);
     }
+
+    //RandomKB
+    private boolean sprintStatus = false;
+    private boolean serverSprint;
+    
+    protected boolean getSprintingStatus(){
+        return this.sprintStatus;
+    }
+        
+    protected void setSprintingStatus(final boolean flag){
+        this.sprintStatus = flag;
+    }
+        
+    public void setServerSprinting(final boolean flag){
+        this.serverSprint = flag;
+    }
+       
+    public boolean isServerSprinting(){
+        if(!RandomKB.SprintStatusReset()){
+            return this.serverSprint ? false : true; // Revert sprint status.
+        }
+     
+        return this.serverSprint;
+    }
+    //RandomKB
 }
diff --git a/src/main/java/net/minecraft/server/EntityHuman.java b/src/main/java/net/minecraft/server/EntityHuman.java
index eb54e7f5..51de5285 100644
--- a/src/main/java/net/minecraft/server/EntityHuman.java
+++ b/src/main/java/net/minecraft/server/EntityHuman.java
@@ -3,6 +3,10 @@ package net.minecraft.server;
 import com.google.common.base.Charsets;
 import com.google.common.collect.Lists;
 import com.mojang.authlib.GameProfile;
+
+import eu.shifo.pvp.RandomKB;
+import net.jafama.FastMath;
+
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
@@ -968,8 +972,8 @@ public abstract class EntityHuman extends EntityLiving {
 
                 int i = b0 + EnchantmentManager.a((EntityLiving) this);
 
-                if (this.isSprinting()) {
-                    ++i;
+                if (this.isServerSprinting()) {
+                    i++;
                 }
 
                 if (f > 0.0F || f1 > 0.0F) {
@@ -1000,12 +1004,49 @@ public abstract class EntityHuman extends EntityLiving {
                     double d2 = entity.motZ;
                     boolean flag2 = entity.damageEntity(DamageSource.playerAttack(this), f);
 
+                    final boolean BetterSprintDetection = RandomKB.BetterSprintDetectionEnabled();
+                    final double ExtraHorizontal = RandomKB.getExtraHorizontal();
+                    final double ExtraVertical = RandomKB.getExtraVertical();
+                    final double KnockbackReductionHor = RandomKB.getKnockbackReductionHor();
+                    final double KnockbackReductionVer = RandomKB.getKnockbackReductionVer();
+
                     if (flag2) {
-                        if (i > 0) {
-                            entity.g((double) (-MathHelper.sin(this.yaw * 3.1415927F / 180.0F) * (float) i * 0.5F), 0.1D, (double) (MathHelper.cos(this.yaw * 3.1415927F / 180.0F) * (float) i * 0.5F));
-                            this.motX *= 0.6D;
-                            this.motZ *= 0.6D;
-                            this.setSprinting(false);
+
+                        // Update sprint status only when player is attacked.
+                        if(BetterSprintDetection)
+                            this.setSprintingStatus(this.isServerSprinting());
+                        else 
+                            this.setSprintingStatus(false); // If BetterSprint is disabled then prevent SprintStatus from being "true"
+
+                        int conditionB = 0;
+
+                        if (entity.getSprintingStatus()) conditionB |= 0x100;
+                        if (RandomKB.KnockbackReductionOnAllKB()) conditionB |= 0x200;
+                
+                        final boolean condition = (conditionB & 0x100) > 0 ? ((conditionB & 0x200) > 0) : true;
+
+                        if (i > 0 && condition) {
+                            entity.g(-FastMath.sin(this.yaw * FastMath.PI / 180.0D) * i * ExtraHorizontal, 
+                                ExtraVertical, 
+                                FastMath.cos(this.yaw * FastMath.PI / 180.0D) * i * ExtraHorizontal
+                            );
+                                                       
+                            if(!BetterSprintDetection){
+                                // This code doesn't work at all!
+                                this.motX *= KnockbackReductionHor;
+                                if(this.motY > 0) this.motY *= KnockbackReductionVer;
+                                this.motZ *= KnockbackReductionHor;
+                                // This code doesn't work at all!
+                            }
+                            
+                            if(RandomKB.SprintStatusReset()) this.setServerSprinting(false);
+                        }
+                                                    
+                        if(entity.getSprintingStatus()){
+                            entity.motX *= RandomKB.getKnockbackReductionHor();
+                            if(entity.motY > 0) entity.motY *= RandomKB.getKnockbackReductionVer();
+                            entity.motZ *= RandomKB.getKnockbackReductionHor();
+                            if(RandomKB.BetterSprintStatusReset()) entity.setSprintingStatus(false);                        
                         }
 
                         if (entity instanceof EntityPlayer && entity.velocityChanged) {
diff --git a/src/main/java/net/minecraft/server/EntityLiving.java b/src/main/java/net/minecraft/server/EntityLiving.java
index f643b29b..476fc8f6 100644
--- a/src/main/java/net/minecraft/server/EntityLiving.java
+++ b/src/main/java/net/minecraft/server/EntityLiving.java
@@ -3,6 +3,10 @@ package net.minecraft.server;
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.common.collect.Maps;
+
+import eu.shifo.pvp.RandomKB;
+import net.jafama.FastMath;
+
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
@@ -787,15 +791,26 @@ public abstract class EntityLiving extends Entity {
 
                     if (entity != null) {
                         double d0 = entity.locX - this.locX;
-
                         double d1;
 
-                        for (d1 = entity.locZ - this.locZ; d0 * d0 + d1 * d1 < 1.0E-4D; d1 = (Math.random() - Math.random()) * 0.01D) {
-                            d0 = (Math.random() - Math.random()) * 0.01D;
+                        for (d1 = entity.locZ - this.locZ; d0 * d0 + d1 * d1 < 1.0E-4D; d1 = (FastMath.random() - FastMath.random()) * 0.01D) {
+                            d0 = (FastMath.random() - FastMath.random()) * 0.01D;
+                        } // readded
+
+                        double d2 = entity.locY - this.locY;
+                        double d3 = 0.0;
+
+                        if(RandomKB.DistanceKBEnabled() && !this.onGround){
+                            final double Friction = RandomKB.getDistanceKBFriction();
+
+                            if(d2 > 0) d3 = (entity.locY - entity.fallDistance) - this.locY;
+                            else d3 = d2;
+
+                            d3 = d3 / FastMath.sqrt(d0*d0+d3*d3+d1*d1) / Friction;
                         }
 
                         this.aw = (float) (MathHelper.b(d1, d0) * 180.0D / 3.1415927410125732D - (double) this.yaw);
-                        this.a(entity, f, d0, d1);
+                        this.a(entity, d0, d1, d2, d3);
                     } else {
                         this.aw = (float) ((int) (Math.random() * 2.0D) * 180);
                     }
@@ -885,21 +900,51 @@ public abstract class EntityLiving extends Entity {
     protected void dropEquipment(boolean flag, int i) {}
 
     public void a(Entity entity, float f, double d0, double d1) {
+        this.a(entity, d0, d1, 0, 0);
+    }
+
+    public void a(Entity entity, final double d0, final double d1, final double d2, final double d3){
         if (this.random.nextDouble() >= this.getAttributeInstance(GenericAttributes.c).getValue()) {
             this.ai = true;
-            float f1 = MathHelper.sqrt(d0 * d0 + d1 * d1);
-            float f2 = 0.4F;
-
-            this.motX /= 2.0D;
-            this.motY /= 2.0D;
-            this.motZ /= 2.0D;
-            this.motX -= d0 / (double) f1 * (double) f2;
-            this.motY += (double) f2;
-            this.motZ -= d1 / (double) f1 * (double) f2;
-            if (this.motY > 0.4000000059604645D) {
-                this.motY = 0.4000000059604645D;
+
+            final double oldMotX = this.motX;
+            final double oldMotY = this.motY;
+            final double oldMotZ = this.motZ;
+
+            final double Horizontal = RandomKB.getHorizontal();
+            final double Vertical = this.onGround || !RandomKB.airKnockback() ? RandomKB.getVertical() : RandomKB.getAirVertical();
+            final double Friction = RandomKB.getFriction();
+            final double VerticalLimit = RandomKB.getVerticalLimit();
+
+            final double magnitude = RandomKB.UseTrigonometry() ? 0 : FastMath.sqrt(d0*d0+d2*d2+d1*d1);
+
+            this.motX /= Friction;
+            this.motY /= Friction;
+            this.motY += d3; // 'this.motY /= Friction + d3' makes kb broken a bit
+            this.motZ /= Friction;
+            this.motY += Vertical;
+
+            if (RandomKB.UseTrigonometry()){
+                this.g(                    
+                    -FastMath.sin(entity.yaw * FastMath.PI / 180.0F) * Horizontal, 0, 
+                    FastMath.cos(entity.yaw * FastMath.PI / 180.0F) * Horizontal
+                );
+            } else {
+                this.motX -= d0 / magnitude * Horizontal;
+                this.motZ -= d1 / magnitude * Horizontal;
+            }
+
+            if (this.motY > VerticalLimit) {
+                this.motY = VerticalLimit;
             }
 
+            if (RandomKB.DeltaKnockback()) {
+                final double[] delta = { this.motX - oldMotX, this.motY - oldMotY, this.motZ - oldMotZ }; 
+                this.motX = oldMotX + delta[0];
+                this.motY = oldMotY + delta[1];
+                this.motZ = oldMotZ + delta[2];  
+            }
+          
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/PlayerConnection.java b/src/main/java/net/minecraft/server/PlayerConnection.java
index 5740e492..151447c9 100644
--- a/src/main/java/net/minecraft/server/PlayerConnection.java
+++ b/src/main/java/net/minecraft/server/PlayerConnection.java
@@ -1246,10 +1246,12 @@ public class PlayerConnection implements PacketListenerPlayIn, IUpdatePlayerList
 
         case 3:
             this.player.setSprinting(true);
+            this.player.setServerSprinting(true);
             break;
 
         case 4:
             this.player.setSprinting(false);
+            this.player.setServerSprinting(false);
             break;
 
         case 5:
-- 
2.36.1.windows.1

